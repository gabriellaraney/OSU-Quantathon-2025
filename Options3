import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import datetime
import warnings
from math import log, sqrt, exp
from scipy.stats import norm
from hmmlearn import hmm
from sklearn.preprocessing import StandardScaler
from matplotlib.ticker import FuncFormatter

warnings.filterwarnings('ignore')

# =============================================================================
# 1. Load and Preprocess Data
# =============================================================================
print("Loading dataset...")
# Expected headers: Date, S&P500, Bond Rate, PrDec, PrInc, Dates, IVOL_PUT_12M_MOV_AVG_30D_HIST, IVOL_CALL_12M_MOV_AVG_30D_HIST
data = pd.read_csv('Combined_SPX_Data_3.csv')
data['Date'] = pd.to_datetime(data['Date'])
data.sort_values('Date', inplace=True)
data.set_index('Date', inplace=True)

if data.isnull().sum().sum() > 0:
    data.fillna(method='ffill', inplace=True)
    data.fillna(method='bfill', inplace=True)

data['S&P500_Return'] = data['S&P500'].pct_change()
data = data.dropna()

# =============================================================================
# 2. Regime Detection via HMM
# =============================================================================
features = ['S&P500_Return', 'PrDec', 'PrInc']
scaler = StandardScaler()
scaled_data = scaler.fit_transform(data[features])

def train_hmm_with_multiple_starts(X, n_states=2, n_attempts=10):
    best_model = None
    best_score = float('-inf')
    print(f"Training HMM with {n_states} states, {n_attempts} attempts...")
    for i in range(n_attempts):
        model = hmm.GaussianHMM(n_components=n_states, covariance_type="full",
                                n_iter=1000, tol=1e-4, random_state=i*42, init_params="mcw")
        try:
            model.fit(X)
            score = model.score(X)
            if score > best_score:
                best_score = score
                best_model = model
            print(f"Attempt {i+1}: Log-likelihood {score:.2f}")
        except Exception as e:
            print(f"Attempt {i+1} failed: {str(e)}")
    return best_model, best_score

n_states = 2
best_model, best_score = train_hmm_with_multiple_starts(scaled_data, n_states=n_states, n_attempts=10)
if best_model is None:
    raise Exception("Failed to train a converging HMM model.")

data['Regime'] = best_model.predict(scaled_data)

# Determine appropriate strategy for each regime
regime_strategy = {}
for i in range(best_model.n_components):
    regime_data = data[data['Regime'] == i]
    pr_dec_mean = regime_data['PrDec'].mean()
    pr_inc_mean = regime_data['PrInc'].mean()
    ratio = pr_dec_mean / pr_inc_mean if pr_inc_mean != 0 else 1
    regime_strategy[i] = 'BUY_CALL' if ratio > 1.2 else 'BUY_PUT'
    print(f"Regime {i} (ratio = {ratio:.2f}) mapped to strategy: {regime_strategy[i]}")

data['Strategy'] = data['Regime'].map(regime_strategy)
if 'Bond Rate' not in data.columns:
    data['Bond Rate'] = 0.02

# =============================================================================
# 3. Define Blackâ€“Scholes Pricing Functions
# =============================================================================
def black_scholes_call(S, K, T, r, sigma):
    """Calculate call option price using Black-Scholes formula"""
    if T <= 0:
        return max(S - K, 0)  # Intrinsic value at expiration
    d1 = (log(S/K) + (r + 0.5 * sigma**2)*T) / (sigma * sqrt(T))
    d2 = d1 - sigma * sqrt(T)
    return S * norm.cdf(d1) - K * exp(-r * T) * norm.cdf(d2)

def black_scholes_put(S, K, T, r, sigma):
    """Calculate put option price using Black-Scholes formula"""
    if T <= 0:
        return max(K - S, 0)  # Intrinsic value at expiration
    d1 = (log(S/K) + (r + 0.5 * sigma**2)*T) / (sigma * sqrt(T))
    d2 = d1 - sigma * sqrt(T)
    return K * exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)

# =============================================================================
# 4. Backtesting the Option-Enhanced Regime-Switching Strategy
# =============================================================================
# For bullish regimes (BUY_CALL): 90% in S&P500 and 10% in 1-year ATM calls
# For bearish regimes (BUY_PUT): 90% in bonds (earning Bond Rate) and 10% in 1-year ATM puts
initial_investment = 1000000

# DataFrame to record daily portfolio and option data
portfolio_data = pd.DataFrame(index=data.index, columns=[
    'Regime', 'Strategy', 'Portfolio_Value', 'SP_Allocation', 'Bond_Allocation',
    'Option_Type', 'Option_Strike', 'Option_Units', 'Option_Value', 'Option_Expiry',
    'Option_Remaining_Days', 'Option_IV', 'Daily_Return'
])
portfolio_data['Regime'] = data['Regime']
portfolio_data['Strategy'] = data['Strategy']

# Constants
TRADING_DAYS = 252
OPTION_DURATION_DAYS = 365  # 1-year options

current_strategy = None
option_positions = []  # Track all options (allows handling expired options better)
portfolio_value = initial_investment
sp_allocation = 0
bond_allocation = 0

for date, row in data.iterrows():
    current_date = date
    new_strategy = row['Strategy']  # 'BUY_CALL' or 'BUY_PUT'
    S = row['S&P500']
    sp_return = row['S&P500_Return']
    r_daily = row['Bond Rate'] / TRADING_DAYS
    
    # Default option data
    active_option_type = None
    active_option_strike = None
    active_option_units = 0
    active_option_value = 0
    active_option_expiry = None
    active_option_remaining_days = 0
    active_option_iv = 0
    total_option_value = 0
    
    # On regime switch (or first day), adjust portfolio allocation
    if current_strategy is None or new_strategy != current_strategy:
        # Close existing options (if any)
        for option in option_positions:
            if option['type'] == 'call':
                sigma_current = row.get('IVOL_CALL_12M_MOV_AVG_30D_HIST', 0.2)
                sigma_current = max(sigma_current, 0.1)  # Ensure minimum volatility
            else:
                sigma_current = row.get('IVOL_PUT_12M_MOV_AVG_30D_HIST', 0.2)
                sigma_current = max(sigma_current, 0.1)  # Ensure minimum volatility
                
            remaining_days = max((option['expiry_date'] - current_date).days, 0)
            T_remaining = remaining_days / 365.0
            
            if option['type'] == 'call':
                current_opt_price = black_scholes_call(S, option['strike'], T_remaining, row['Bond Rate'], sigma_current)
            else:
                current_opt_price = black_scholes_put(S, option['strike'], T_remaining, row['Bond Rate'], sigma_current)
                
            option['current_value'] = option['units'] * current_opt_price
        
        # Calculate portfolio value before reallocation
        if current_strategy is not None:
            option_total = sum(opt['current_value'] for opt in option_positions)
            portfolio_value = (sp_allocation if current_strategy == 'BUY_CALL' else bond_allocation) + option_total
        
        # Clear expired options
        option_positions = [opt for opt in option_positions if (opt['expiry_date'] - current_date).days > 0]
        
        # Reallocate portfolio based on new regime
        if new_strategy == 'BUY_CALL':
            sp_allocation = 0.9 * portfolio_value  # 90% to S&P500
            bond_allocation = 0
        else:
            sp_allocation = 0
            bond_allocation = 0.9 * portfolio_value  # 90% to bonds
        
        # Use 10% of portfolio to buy a new option contract
        option_alloc = 0.1 * portfolio_value
        expiry_date = current_date + pd.Timedelta(days=OPTION_DURATION_DAYS)
        
        if new_strategy == 'BUY_CALL':
            sigma_new = row.get('IVOL_CALL_12M_MOV_AVG_30D_HIST', 0.2)
            sigma_new = max(sigma_new, 0.1)  # Ensure minimum volatility
            opt_price = black_scholes_call(S, S, 1, row['Bond Rate'], sigma_new)
            opt_type = 'call'
        else:
            sigma_new = row.get('IVOL_PUT_12M_MOV_AVG_30D_HIST', 0.2)
            sigma_new = max(sigma_new, 0.1)  # Ensure minimum volatility
            opt_price = black_scholes_put(S, S, 1, row['Bond Rate'], sigma_new)
            opt_type = 'put'
            
        units = option_alloc / opt_price if opt_price > 0 else 0
        
        new_option = {
            'type': opt_type,
            'strike': S,
            'units': units,
            'expiry_date': expiry_date,
            'entry_date': current_date,
            'current_value': units * opt_price,
            'is_active': True
        }
        
        option_positions.append(new_option)
        
        # Track the active option for reporting
        active_option_type = opt_type
        active_option_strike = S
        active_option_units = units
        active_option_expiry = expiry_date
        active_option_remaining_days = OPTION_DURATION_DAYS
        active_option_iv = sigma_new
        active_option_value = units * opt_price
        
        current_strategy = new_strategy
    else:
        # Regime remains the same: update core allocation values
        if current_strategy == 'BUY_CALL':
            sp_allocation = sp_allocation * (1 + sp_return)
        else:
            bond_allocation = bond_allocation * (1 + r_daily)
        
        # Check for options expiring today
        for option in option_positions:
            remaining_days = max((option['expiry_date'] - current_date).days, 0)
            
            # Handle expiration event
            if remaining_days == 0 and option['is_active']:
                option['is_active'] = False
                if option['type'] == 'call':
                    # At call expiration, get intrinsic value
                    intrinsic_value = max(S - option['strike'], 0)
                    option['current_value'] = option['units'] * intrinsic_value
                else:
                    # At put expiration, get intrinsic value
                    intrinsic_value = max(option['strike'] - S, 0)
                    option['current_value'] = option['units'] * intrinsic_value
                
                # Add expired option value to appropriate allocation
                if current_strategy == 'BUY_CALL':
                    sp_allocation += option['current_value']
                else:
                    bond_allocation += option['current_value']
            
            # Revalue active options
            elif option['is_active']:
                T_remaining = remaining_days / 365.0
                
                if option['type'] == 'call':
                    sigma_current = row.get('IVOL_CALL_12M_MOV_AVG_30D_HIST', 0.2)
                    sigma_current = max(sigma_current, 0.1)  # Ensure minimum volatility
                    opt_price = black_scholes_call(S, option['strike'], T_remaining, row['Bond Rate'], sigma_current)
                else:
                    sigma_current = row.get('IVOL_PUT_12M_MOV_AVG_30D_HIST', 0.2)
                    sigma_current = max(sigma_current, 0.1)  # Ensure minimum volatility
                    opt_price = black_scholes_put(S, option['strike'], T_remaining, row['Bond Rate'], sigma_current)
                
                option['current_value'] = option['units'] * opt_price
                
                # Track the most recently purchased option for reporting
                if option['entry_date'] == max(opt['entry_date'] for opt in option_positions if opt['is_active']):
                    active_option_type = option['type']
                    active_option_strike = option['strike']
                    active_option_units = option['units']
                    active_option_expiry = option['expiry_date']
                    active_option_remaining_days = remaining_days
                    active_option_iv = sigma_current
                    active_option_value = option['current_value']
    
    # Calculate total option value across all active options
    total_option_value = sum(opt['current_value'] for opt in option_positions if opt['is_active'])
    
    # Calculate total portfolio value
    current_portfolio_value = (sp_allocation if current_strategy == 'BUY_CALL' else bond_allocation) + total_option_value
    
    # Record data for this day
    portfolio_data.loc[date, 'Portfolio_Value'] = current_portfolio_value
    portfolio_data.loc[date, 'SP_Allocation'] = sp_allocation
    portfolio_data.loc[date, 'Bond_Allocation'] = bond_allocation
    portfolio_data.loc[date, 'Option_Type'] = active_option_type
    portfolio_data.loc[date, 'Option_Strike'] = active_option_strike
    portfolio_data.loc[date, 'Option_Units'] = active_option_units
    portfolio_data.loc[date, 'Option_Value'] = total_option_value
    portfolio_data.loc[date, 'Option_Expiry'] = active_option_expiry
    portfolio_data.loc[date, 'Option_Remaining_Days'] = active_option_remaining_days
    portfolio_data.loc[date, 'Option_IV'] = active_option_iv
    
    # Update portfolio value for next iteration
    portfolio_value = current_portfolio_value

# Calculate daily returns
portfolio_data['Daily_Return'] = portfolio_data['Portfolio_Value'].pct_change()

# =============================================================================
# 5. Buy-and-Hold Portfolio & Performance Metrics
# =============================================================================
buyhold_series = initial_investment * (1 + data['S&P500_Return']).cumprod()
data['BuyHold_Portfolio'] = buyhold_series
data['BuyHold_Peak'] = data['BuyHold_Portfolio'].cummax()
data['BuyHold_Drawdown'] = (data['BuyHold_Portfolio'] / data['BuyHold_Peak'] - 1) * 100

portfolio_data['Cumulative_Max'] = portfolio_data['Portfolio_Value'].cummax()
portfolio_data['Drawdown'] = (portfolio_data['Portfolio_Value'] / portfolio_data['Cumulative_Max'] - 1) * 100

total_return = portfolio_data['Portfolio_Value'].iloc[-1] / initial_investment - 1
num_days = (portfolio_data.index[-1] - portfolio_data.index[0]).days
annual_return = (1 + total_return)**(365/num_days) - 1
annual_vol = portfolio_data['Daily_Return'].std() * np.sqrt(TRADING_DAYS)
rf_annual = data['Bond Rate'].iloc[0]
sharpe_ratio = (annual_return - rf_annual) / annual_vol if annual_vol != 0 else np.nan
downside_std = portfolio_data.loc[portfolio_data['Daily_Return'] < 0, 'Daily_Return'].std() * np.sqrt(TRADING_DAYS)
sortino_ratio = (annual_return - rf_annual) / downside_std if downside_std != 0 else np.nan
max_drawdown = portfolio_data['Drawdown'].min()

print("\nPerformance Metrics for Regime-Switching Portfolio:")
print(f"  Total Return: {total_return*100:.2f}%")
print(f"  Annualized Return: {annual_return*100:.2f}%")
print(f"  Annualized Volatility: {annual_vol*100:.2f}%")
print(f"  Sharpe Ratio: {sharpe_ratio:.2f}")
print(f"  Sortino Ratio: {sortino_ratio:.2f}")
print(f"  Maximum Drawdown: {max_drawdown:.2f}%")

# =============================================================================
# 6. Output CSV with Daily Component Values
# =============================================================================
portfolio_data['Call_Option_Value'] = portfolio_data.apply(lambda row: row['Option_Value'] if row['Option_Type']=='call' else 0, axis=1)
portfolio_data['Put_Option_Value'] = portfolio_data.apply(lambda row: row['Option_Value'] if row['Option_Type']=='put' else 0, axis=1)

daily_components = portfolio_data[['SP_Allocation', 'Bond_Allocation', 'Call_Option_Value', 'Put_Option_Value']]
daily_components['Total_Portfolio_Value'] = portfolio_data['Portfolio_Value']
daily_components.to_csv('daily_portfolio_components.csv')
print("\nDaily portfolio component values saved to 'daily_portfolio_components.csv'")

# =============================================================================
# 7. Plot Charts
# =============================================================================
fig, axs = plt.subplots(3, 1, figsize=(15, 15))

def thousands(x, pos):
    return f'${x/1000:.0f}k'
formatter = FuncFormatter(thousands)

for col in ['Option_Value', 'SP_Allocation', 'Bond_Allocation']:
    portfolio_data[col] = pd.to_numeric(portfolio_data[col], errors='coerce').fillna(0)

# Portfolio Value Comparison
axs[0].plot(data.index, data['BuyHold_Portfolio'], label='Buy-and-Hold', color='blue')
axs[0].plot(portfolio_data.index, portfolio_data['Portfolio_Value'], label='Regime-Switching', color='green')
axs[0].set_title('Portfolio Value Comparison')
axs[0].set_ylabel('Portfolio Value')
axs[0].legend()
axs[0].grid(True, alpha=0.3)
axs[0].yaxis.set_major_formatter(formatter)

# Highlight regime changes
last_date = None
last_regime = None
for dt, regime in zip(data.index, data['Regime']):
    if last_regime is None:
        last_regime = regime
        last_date = dt
    elif regime != last_regime:
        axs[0].axvspan(last_date, dt, alpha=0.1, color=f'C{last_regime}')
        last_regime = regime
        last_date = dt
if last_date is not None:
    axs[0].axvspan(last_date, data.index[-1], alpha=0.1, color=f'C{last_regime}')

# Drawdown Comparison
axs[1].plot(data.index, data['BuyHold_Drawdown'], label='Buy-and-Hold Drawdown', color='red')
axs[1].plot(portfolio_data.index, portfolio_data['Drawdown'], label='Regime-Switching Drawdown', color='orange')
axs[1].set_title('Drawdown Comparison')
axs[1].set_ylabel('Drawdown (%)')
axs[1].legend()
axs[1].grid(True, alpha=0.3)

# Portfolio Composition
axs[2].stackplot(portfolio_data.index, 
                 portfolio_data['Option_Value'],
                 portfolio_data['SP_Allocation'],
                 portfolio_data['Bond_Allocation'],
                 labels=['Options', 'S&P500', 'Bonds'],
                 colors=['purple', 'green', 'lightblue'])
axs[2].set_title('Portfolio Composition')
axs[2].set_ylabel('Allocation Value')
axs[2].legend(loc='upper left')
axs[2].grid(True, alpha=0.3)
axs[2].yaxis.set_major_formatter(formatter)

plt.tight_layout()
plt.savefig('regime_switching_performance.png', dpi=300)
print("Performance chart saved to 'regime_switching_performance.png'")

# Save results to CSV
portfolio_data.to_csv('regime_switching_option_backtest_results.csv')
print("Full portfolio time series saved to 'regime_switching_option_backtest_results.csv'")
