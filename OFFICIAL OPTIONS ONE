import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from hmmlearn import hmm
from sklearn.preprocessing import StandardScaler
from matplotlib.ticker import FuncFormatter
import warnings
from scipy.stats import norm

warnings.filterwarnings('ignore')

# ----------------------------
# User Settings & Helper Functions
# ----------------------------
option_alloc_fraction = 0.10  # 10% of portfolio allocated to call options in BUY_CALL regime
TRADING_DAYS = 252  # trading days in a year

def black_scholes_call(S, K, T, r, sigma):
    """Calculate ATM call option price using Black-Scholes."""
    if T <= 0:
        return max(S - K, 0)
    d1 = (np.log(S/K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

# ----------------------------
# 1. Load and Preprocess Data
# ----------------------------
data = pd.read_csv('Combined_SPX_Data_3.csv')
data['Date'] = pd.to_datetime(data['Date'])
data.sort_values('Date', inplace=True)

if data.isnull().sum().sum() > 0:
    data = data.fillna(method='ffill').fillna(method='bfill')

data['S&P500_Return'] = data['S&P500'].pct_change()
data = data.dropna()

# Create a trading day counter (0,1,2,...) for simulation purposes
data = data.reset_index(drop=True)
data['Day'] = np.arange(len(data))

# ----------------------------
# 2. Regime Detection via HMM
# ----------------------------
features = ['S&P500_Return', 'PrDec', 'PrInc']
scaler = StandardScaler()
scaled_data = scaler.fit_transform(data[features])

def train_hmm_with_multiple_starts(X, n_states=2, n_attempts=20):
    best_model = None
    best_score = float('-inf')
    for i in range(n_attempts):
        model = hmm.GaussianHMM(n_components=n_states,
                                covariance_type="full",
                                n_iter=1000,
                                tol=1e-4,
                                random_state=i*42,
                                init_params="mcw")
        try:
            model.fit(X)
            score = model.score(X)
            if score > best_score:
                best_score = score
                best_model = model
        except Exception as e:
            continue
    return best_model, best_score

n_states = 2
best_model, best_score = train_hmm_with_multiple_starts(scaled_data, n_states=n_states, n_attempts=10)
hidden_states = best_model.predict(scaled_data)
data['Regime'] = hidden_states

# ----------------------------
# Regime Analysis & Strategy Mapping
# ----------------------------
regime_strategy = {}
for i in range(n_states):
    regime_data = data[data['Regime'] == i]
    ratio = regime_data['PrDec'].mean() / regime_data['PrInc'].mean() if regime_data['PrInc'].mean() != 0 else 1
    regime_strategy[i] = "BUY_CALL" if ratio > 1.2 else "BUY_PUT"
data['Strategy'] = data['Regime'].map(regime_strategy)
if 'Bond Rate' not in data.columns:
    data['Bond Rate'] = 0.02

# ----------------------------
# Helper Function to Shade Regime Regions
# ----------------------------
def add_regime_shading(ax, df):
    # Define colors for each regime
    colors = {0: 'lightcoral', 1: 'lightgreen'}
    labeled = {}
    # Group data by contiguous regime periods
    for _, group in df.groupby((df['Regime'] != df['Regime'].shift()).cumsum()):
        start_date = group['Date'].iloc[0]
        end_date = group['Date'].iloc[-1]
        regime = group['Regime'].iloc[0]
        label = f"Regime {regime}" if regime not in labeled else None
        if label is not None:
            labeled[regime] = True
        ax.axvspan(start_date, end_date, color=colors.get(regime, 'grey'), alpha=0.2, label=label)

# ----------------------------
# 3. Backtesting with Option Overlay in BUY_CALL
# ----------------------------
initial_investment = 100000
portfolio_value = initial_investment

# Prepare columns for enhanced strategy:
data['OptionEnhanced_Portfolio'] = np.nan
data['Stock_Value'] = np.nan
data['Option_Value'] = np.nan

# State variables for option overlay (for BUY_CALL regime)
active_option = False
option_strike = None
option_quantity = 0
option_expiry_day = None  # trading day counter at expiry
stock_value = 0

# We'll use the trading day counter from the 'Day' column.
for i, row in data.iterrows():
    current_day = row['Day']
    S = row['S&P500']
    sp_return = row['S&P500_Return']
    bond_rate = row['Bond Rate']
    strategy = row['Strategy']
    iv_call = row['IVOL_CALL_12M_MOV_AVG_30D_HIST'] / 100  # convert percentage to decimal

    if strategy == "BUY_CALL":
        if not active_option:
            stock_value = 0.90 * portfolio_value
            option_alloc = 0.10 * portfolio_value
            option_price = black_scholes_call(S, S, 1, bond_rate, iv_call)
            option_quantity = option_alloc / option_price if option_price > 0 else 0
            option_strike = S
            option_expiry_day = current_day + TRADING_DAYS
            active_option = True
            option_value = option_quantity * option_price
        else:
            stock_value = stock_value * (1 + sp_return)
            days_remaining = max(0, option_expiry_day - current_day)
            T_remaining = days_remaining / TRADING_DAYS
            option_price = black_scholes_call(S, option_strike, T_remaining, bond_rate, iv_call)
            option_value = option_quantity * option_price
            if days_remaining <= 0:
                intrinsic = max(S - option_strike, 0)
                option_value = option_quantity * intrinsic
                stock_value += option_value
                active_option = False
                option_quantity = 0
                option_strike = None
                option_expiry_day = None
        portfolio_value = stock_value + (option_value if active_option else 0)
    else:
        if active_option:
            days_remaining = max(0, option_expiry_day - current_day)
            T_remaining = days_remaining / TRADING_DAYS
            option_price = black_scholes_call(S, option_strike, T_remaining, bond_rate, iv_call) if T_remaining > 0 else max(S - option_strike, 0)
            option_value = option_quantity * option_price
            portfolio_value = stock_value + option_value
            active_option = False
            option_quantity = 0
            option_strike = None
            option_expiry_day = None
        portfolio_value = portfolio_value * (1 + bond_rate/252)
        stock_value = 0
        option_value = 0

    data.loc[i, 'OptionEnhanced_Portfolio'] = portfolio_value
    data.loc[i, 'Stock_Value'] = stock_value
    data.loc[i, 'Option_Value'] = option_value

# ----------------------------
# 4. Performance Metrics and Plotting (unchanged)
# ----------------------------
cumulative_return = (1 + data['S&P500_Return']).cumprod()
data['BuyHold_Portfolio'] = initial_investment * cumulative_return

data['BuyHold_Peak'] = data['BuyHold_Portfolio'].cummax()
data['BuyHold_Drawdown'] = (data['BuyHold_Portfolio'] / data['BuyHold_Peak'] - 1) * 100
data['OptionEnhanced_Peak'] = data['OptionEnhanced_Portfolio'].cummax()
data['OptionEnhanced_Drawdown'] = (data['OptionEnhanced_Portfolio'] / data['OptionEnhanced_Peak'] - 1) * 100

bh_total_return = (data['BuyHold_Portfolio'].iloc[-1] / initial_investment - 1) * 100
oe_total_return = (data['OptionEnhanced_Portfolio'].iloc[-1] / initial_investment - 1) * 100

# ----------------------------
# Additional Performance Metrics based on Compounded Daily Bond Rate
# ----------------------------
# Compute compounded daily bond rate from the annual rate (assumed constant, e.g., 2%)
annual_bond_rate = data['Bond Rate'].iloc[0]
daily_bond_rate = (1 + annual_bond_rate)**(1/252) - 1

# Compute daily returns for portfolios
data['BuyHold_daily_return'] = data['BuyHold_Portfolio'].pct_change()
data['OptionEnhanced_daily_return'] = data['OptionEnhanced_Portfolio'].pct_change()

# Compute excess returns by subtracting the compounded daily bond rate
data['BuyHold_excess_return'] = data['BuyHold_daily_return'] - daily_bond_rate
data['OptionEnhanced_excess_return'] = data['OptionEnhanced_daily_return'] - daily_bond_rate

# Compute Sharpe Ratios (annualized)
sharpe_bh = (data['BuyHold_excess_return'].mean() / data['BuyHold_excess_return'].std()) * np.sqrt(252)
sharpe_oe = (data['OptionEnhanced_excess_return'].mean() / data['OptionEnhanced_excess_return'].std()) * np.sqrt(252)

# Compute downside standard deviation for Sortino Ratio (only consider days with negative excess return)
downside_bh = data['BuyHold_excess_return'][data['BuyHold_excess_return'] < 0]
downside_std_bh = downside_bh.std()

downside_oe = data['OptionEnhanced_excess_return'][data['OptionEnhanced_excess_return'] < 0]
downside_std_oe = downside_oe.std()

sortino_bh = (data['BuyHold_excess_return'].mean() / downside_std_bh) * np.sqrt(252)
sortino_oe = (data['OptionEnhanced_excess_return'].mean() / downside_std_oe) * np.sqrt(252)

# Maximum drawdowns
max_drawdown_bh = data['BuyHold_Drawdown'].min()
max_drawdown_oe = data['OptionEnhanced_Drawdown'].min()

# Relative return versus benchmark
relative_return = oe_total_return - bh_total_return

# Print performance metrics
print("Performance Metrics:")
print(f"Buy-and-Hold Total Return: {bh_total_return:.2f}%")
print(f"Option-Enhanced Total Return: {oe_total_return:.2f}%")
print(f"Benchmark (Buy-and-Hold) Return: {bh_total_return:.2f}%")
print(f"Return vs Benchmark: {relative_return:.2f}%")
print()
print("Sharpe Ratios (Excess over compounded bond rate):")
print(f"Buy-and-Hold Sharpe Ratio: {sharpe_bh:.2f}")
print(f"Option-Enhanced Sharpe Ratio: {sharpe_oe:.2f}")
print()
print("Sortino Ratios (Excess over compounded bond rate):")
print(f"Buy-and-Hold Sortino Ratio: {sortino_bh:.2f}")
print(f"Option-Enhanced Sortino Ratio: {sortino_oe:.2f}")
print()
print("Maximum Drawdowns:")
print(f"Buy-and-Hold Max Drawdown: {max_drawdown_bh:.2f}%")
print(f"Option-Enhanced Max Drawdown: {max_drawdown_oe:.2f}%")

# ----------------------------
# Chart 1: Portfolio Value Comparison
# ----------------------------
plt.figure(figsize=(10, 6))
ax = plt.gca()
ax.plot(data['Date'], data['BuyHold_Portfolio'], label='Buy-and-Hold', color='blue')
ax.plot(data['Date'], data['OptionEnhanced_Portfolio'], label='Option-Enhanced', color='green')
add_regime_shading(ax, data)
ax.set_title('Portfolio Value Comparison')
ax.set_xlabel('Date')
ax.set_ylabel('Portfolio Value')
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()

# ----------------------------
# Chart 2: Comparable Drawdowns
# ----------------------------
plt.figure(figsize=(10, 6))
ax = plt.gca()
ax.plot(data['Date'], data['BuyHold_Drawdown'], label='Buy-and-Hold Drawdown', color='blue')
ax.plot(data['Date'], data['OptionEnhanced_Drawdown'], label='Option-Enhanced Drawdown', color='red')
add_regime_shading(ax, data)
ax.set_title('Comparable Drawdowns')
ax.set_xlabel('Date')
ax.set_ylabel('Drawdown (%)')
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()

# ----------------------------
# Chart 3: Relative Outperformance
# ----------------------------
relative_outperformance = (data['OptionEnhanced_Portfolio'] / data['BuyHold_Portfolio'] - 1) * 100
plt.figure(figsize=(10, 6))
ax = plt.gca()
ax.plot(data['Date'], relative_outperformance, label='Relative Outperformance (%)', color='purple')
ax.axhline(0, color='black', linestyle='--', linewidth=1)
add_regime_shading(ax, data)
ax.set_title('Relative Outperformance: Option-Enhanced vs Buy-and-Hold')
ax.set_xlabel('Date')
ax.set_ylabel('Relative Outperformance (%)')
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()

# Save results to CSV (including the S&P500 price for reference)
data['S&P500_Price'] = data['S&P500']
data.to_csv('option_enhanced_backtest_results.csv', index=False)
