import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import datetime
import warnings
from math import log, sqrt, exp
from scipy.stats import norm
from hmmlearn import hmm
from sklearn.preprocessing import StandardScaler
from matplotlib.ticker import FuncFormatter

warnings.filterwarnings('ignore')

# =============================================================================
# 1. Load and Preprocess Data
# =============================================================================
print("Loading dataset...")
# Expected headers: Date, S&P500, Bond Rate, PrDec, PrInc, Dates, IVOL_PUT_12M_MOV_AVG_30D_HIST, IVOL_CALL_12M_MOV_AVG_30D_HIST
data = pd.read_csv('Combined_SPX_Data_3.csv')
data['Date'] = pd.to_datetime(data['Date'])
data.sort_values('Date', inplace=True)
data.set_index('Date', inplace=True)

if data.isnull().sum().sum() > 0:
    data.fillna(method='ffill', inplace=True)
    data.fillna(method='bfill', inplace=True)

data['S&P500_Return'] = data['S&P500'].pct_change()
data = data.dropna()

# =============================================================================
# 2. Regime Detection via HMM
# =============================================================================
features = ['S&P500_Return', 'PrDec', 'PrInc']
scaler = StandardScaler()
scaled_data = scaler.fit_transform(data[features])

def train_hmm_with_multiple_starts(X, n_states=2, n_attempts=10):
    best_model = None
    best_score = float('-inf')
    print(f"Training HMM with {n_states} states, {n_attempts} attempts...")
    for i in range(n_attempts):
        model = hmm.GaussianHMM(n_components=n_states, covariance_type="full",
                                n_iter=1000, tol=1e-4, random_state=i*42, init_params="mcw")
        try:
            model.fit(X)
            score = model.score(X)
            if score > best_score:
                best_score = score
                best_model = model
            print(f"Attempt {i+1}: Log-likelihood {score:.2f}")
        except Exception as e:
            print(f"Attempt {i+1} failed: {str(e)}")
    return best_model, best_score

n_states = 2
best_model, best_score = train_hmm_with_multiple_starts(scaled_data, n_states=n_states, n_attempts=10)
if best_model is None:
    raise Exception("Failed to train a converging HMM model.")

data['Regime'] = best_model.predict(scaled_data)

regime_strategy = {}
for i in range(best_model.n_components):
    regime_data = data[data['Regime'] == i]
    pr_dec_mean = regime_data['PrDec'].mean()
    pr_inc_mean = regime_data['PrInc'].mean()
    ratio = pr_dec_mean / pr_inc_mean if pr_inc_mean != 0 else 1
    regime_strategy[i] = 'BUY_CALL' if ratio > 1.2 else 'BUY_PUT'
    print(f"Regime {i} (ratio = {ratio:.2f}) mapped to strategy: {regime_strategy[i]}")

data['Strategy'] = data['Regime'].map(regime_strategy)
if 'Bond Rate' not in data.columns:
    data['Bond Rate'] = 0.02

# =============================================================================
# 3. Define Blackâ€“Scholes Pricing Functions
# =============================================================================
def black_scholes_call(S, K, T, r, sigma):
    if T <= 0:
        return max(S - K, 0)
    d1 = (log(S/K) + (r + 0.5 * sigma**2)*T) / (sigma * sqrt(T))
    d2 = d1 - sigma * sqrt(T)
    return S * norm.cdf(d1) - K * exp(-r * T) * norm.cdf(d2)

def black_scholes_put(S, K, T, r, sigma):
    if T <= 0:
        return max(K - S, 0)
    d1 = (log(S/K) + (r + 0.5 * sigma**2)*T) / (sigma * sqrt(T))
    d2 = d1 - sigma * sqrt(T)
    return K * exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)

# =============================================================================
# 4. Backtesting the Option-Enhanced Regime-Switching Strategy
# =============================================================================
# For bullish regimes (BUY_CALL): 90% in S&P500 and 10% in 1-year ATM calls.
# For bearish regimes (BUY_PUT): 90% in cash (earning Bond Rate) and 10% in 1-year ATM puts.
# On regime switch, close any existing option and purchase a new one with 10% of the portfolio value.
# Otherwise, hold the same option contract and revalue it daily using the current S&P500 level.
initial_investment = 1000000
portfolio_value = initial_investment

# Add a debug flag
enable_debug = True

# DataFrame to record daily portfolio and option data.
portfolio_data = pd.DataFrame(index=data.index, columns=[
    'Regime', 'Strategy', 'Current_Portfolio_Value', 'SP_Allocation', 'Cash_Allocation',
    'Option_Type', 'Option_Strike', 'Option_Units', 'Option_Value', 'Option_Expiry',
    'Option_Remaining_Days', 'Option_IV', 'Daily_Return'
])
portfolio_data['Regime'] = data['Regime']
portfolio_data['Strategy'] = data['Strategy']

current_strategy = None  # Active regime.
option_position = None   # Holds the purchased option details.
sp_allocation = 0
cash_allocation = 0

# For daily cash accrual use trading days (for r_daily); for options T use calendar years.
TRADING_DAYS = 252

for date, row in data.iterrows():
    current_date = date
    new_strategy = row['Strategy']  # 'BUY_CALL' or 'BUY_PUT'
    S = row['S&P500']
    sp_return = row['S&P500_Return']
    r_daily = row['Bond Rate'] / TRADING_DAYS

    # Debug info
    if enable_debug:
        print(f"\n---- Date: {current_date} | S&P500: {S:.2f} | Strategy: {new_strategy} ----")

    # Initialize option tracking variables.
    option_type = None
    option_strike = None
    option_units = 0
    option_value = 0
    option_expiry = None
    option_remaining_days = 0
    option_iv = 0

    # On regime switch (or first day), close existing option and buy a new one.
    if current_strategy is None or new_strategy != current_strategy:
        if enable_debug:
            print(f"Regime switch detected: {current_strategy} -> {new_strategy}")
        
        # If an option is held, close it (i.e. revalue it for closing).
        if option_position is not None:
            if option_position['type'] == 'call':
                sigma_current = row['IVOL_CALL_12M_MOV_AVG_30D_HIST'] if row['IVOL_CALL_12M_MOV_AVG_30D_HIST'] > 0 else 0.2
            else:
                sigma_current = row['IVOL_PUT_12M_MOV_AVG_30D_HIST'] if row['IVOL_PUT_12M_MOV_AVG_30D_HIST'] > 0 else 0.2
            remaining_days = max((option_position['expiry_date'] - current_date).days, 0)
            # Use calendar year (365 days) for option T.
            T_remaining = remaining_days / 365.0
            if option_position['type'] == 'call':
                current_opt_price = black_scholes_call(S, option_position['strike'], T_remaining, row['Bond Rate'], sigma_current)
            else:
                current_opt_price = black_scholes_put(S, option_position['strike'], T_remaining, row['Bond Rate'], sigma_current)
            option_value = option_position['units'] * current_opt_price
            
            if enable_debug:
                print(f"Closing {option_position['type']} option: Strike = {option_position['strike']:.2f}, " +
                      f"Remaining Days = {remaining_days}, IV = {sigma_current:.2f}, " +
                      f"Price = {current_opt_price:.2f}, Value = {option_value:.2f}")
        
        if current_strategy is not None:
            portfolio_value = (sp_allocation if current_strategy == 'BUY_CALL' else cash_allocation) + option_value

        # Reallocate portfolio based on new regime.
        if new_strategy == 'BUY_CALL':
            sp_allocation = 0.9 * portfolio_value  # 90% to S&P500.
            cash_allocation = 0
        else:
            sp_allocation = 0
            cash_allocation = 0.9 * portfolio_value  # 90% to cash.
        
        # Use 10% of portfolio to buy a new option contract.
        option_alloc = 0.1 * portfolio_value
        expiry_date = current_date + pd.Timedelta(days=365)
        if new_strategy == 'BUY_CALL':
            sigma_new = row['IVOL_CALL_12M_MOV_AVG_30D_HIST'] if row['IVOL_CALL_12M_MOV_AVG_30D_HIST'] > 0 else 0.2
            opt_price = black_scholes_call(S, S, 1, row['Bond Rate'], sigma_new)
            opt_type = 'call'
        else:
            sigma_new = row['IVOL_PUT_12M_MOV_AVG_30D_HIST'] if row['IVOL_PUT_12M_MOV_AVG_30D_HIST'] > 0 else 0.2
            opt_price = black_scholes_put(S, S, 1, row['Bond Rate'], sigma_new)
            opt_type = 'put'
        units = option_alloc / opt_price if opt_price > 0 else 0

        option_position = {
            'type': opt_type,
            'strike': S,       # Fixed strike at purchase.
            'units': units,
            'expiry_date': expiry_date,
            'entry_date': current_date
        }
        option_type = opt_type
        option_strike = S
        option_units = units
        option_expiry = expiry_date
        option_remaining_days = 365  # At purchase, 365 days remain.
        option_iv = sigma_new
        option_value = units * opt_price
        
        if enable_debug:
            print(f"Buying new {opt_type} option: Strike = {S:.2f}, Units = {units:.2f}, " + 
                 f"IV = {sigma_new:.2f}, Price = {opt_price:.2f}, Value = {option_value:.2f}")

        current_strategy = new_strategy
    else:
        # Regime remains the same: update core allocation and revalue the existing option.
        if current_strategy == 'BUY_CALL':
            old_sp_value = sp_allocation
            sp_allocation = sp_allocation * (1 + sp_return)
            if enable_debug:
                print(f"S&P500 Allocation: {old_sp_value:.2f} -> {sp_allocation:.2f} (Return: {sp_return*100:.2f}%)")
        else:
            old_cash_value = cash_allocation
            cash_allocation = cash_allocation * (1 + r_daily)
            if enable_debug:
                print(f"Cash Allocation: {old_cash_value:.2f} -> {cash_allocation:.2f} (Daily Rate: {r_daily*100:.4f}%)")
        
        remaining_days = max((option_position['expiry_date'] - current_date).days, 0)
        T_remaining = remaining_days / 365.0
        old_option_value = option_value
        
        if option_position['type'] == 'call':
            sigma_current = row['IVOL_CALL_12M_MOV_AVG_30D_HIST'] if row['IVOL_CALL_12M_MOV_AVG_30D_HIST'] > 0 else 0.2
            if T_remaining <= 0:
                # At expiration, option value is the intrinsic value
                opt_price = max(S - option_position['strike'], 0)
            else:
                # Recalculate option price using current S&P500 level
                opt_price = black_scholes_call(S, option_position['strike'], T_remaining, row['Bond Rate'], sigma_current)
        else:
            sigma_current = row['IVOL_PUT_12M_MOV_AVG_30D_HIST'] if row['IVOL_PUT_12M_MOV_AVG_30D_HIST'] > 0 else 0.2
            if T_remaining <= 0:
                # At expiration, option value is the intrinsic value
                opt_price = max(option_position['strike'] - S, 0)
            else:
                # Recalculate option price using current S&P500 level
                opt_price = black_scholes_put(S, option_position['strike'], T_remaining, row['Bond Rate'], sigma_current)
        
        option_type = option_position['type']
        option_strike = option_position['strike']
        option_units = option_position['units']
        option_expiry = option_position['expiry_date']
        option_remaining_days = remaining_days
        option_iv = sigma_current
        option_value = option_position['units'] * opt_price
        
        if enable_debug:
            print(f"Revaluing {option_type} option: Strike = {option_strike:.2f}, S&P500 = {S:.2f}, " +
                  f"Days Left = {remaining_days}, IV = {sigma_current:.2f}, " +
                  f"Price = {opt_price:.2f}, Value: {old_option_value:.2f} -> {option_value:.2f}")

    current_portfolio_value = (sp_allocation if current_strategy == 'BUY_CALL' else cash_allocation) + option_value

    portfolio_data.loc[date, 'Current_Portfolio_Value'] = current_portfolio_value
    portfolio_data.loc[date, 'SP_Allocation'] = sp_allocation
    portfolio_data.loc[date, 'Cash_Allocation'] = cash_allocation
    portfolio_data.loc[date, 'Option_Type'] = option_type
    portfolio_data.loc[date, 'Option_Strike'] = option_strike
    portfolio_data.loc[date, 'Option_Units'] = option_units
    portfolio_data.loc[date, 'Option_Value'] = option_value
    portfolio_data.loc[date, 'Option_Expiry'] = option_expiry
    portfolio_data.loc[date, 'Option_Remaining_Days'] = option_remaining_days
    portfolio_data.loc[date, 'Option_IV'] = option_iv
    portfolio_value = current_portfolio_value

portfolio_data['Daily_Return'] = portfolio_data['Current_Portfolio_Value'].pct_change()

# =============================================================================
# 5. Buy-and-Hold Portfolio & Performance Metrics
# =============================================================================
buyhold_series = initial_investment * (1 + data['S&P500_Return']).cumprod()
data['BuyHold_Portfolio'] = buyhold_series
data['BuyHold_Peak'] = data['BuyHold_Portfolio'].cummax()
data['BuyHold_Drawdown'] = (data['BuyHold_Portfolio'] / data['BuyHold_Peak'] - 1) * 100

portfolio_data['Cumulative_Max'] = portfolio_data['Current_Portfolio_Value'].cummax()
portfolio_data['Drawdown'] = (portfolio_data['Current_Portfolio_Value'] / portfolio_data['Cumulative_Max'] - 1) * 100

total_return = portfolio_data['Current_Portfolio_Value'].iloc[-1] / initial_investment - 1
num_days = (portfolio_data.index[-1] - portfolio_data.index[0]).days
annual_return = (1 + total_return)**(365/num_days) - 1
annual_vol = portfolio_data['Daily_Return'].std() * np.sqrt(TRADING_DAYS)
rf_annual = data['Bond Rate'].iloc[0]
sharpe_ratio = (annual_return - rf_annual) / annual_vol if annual_vol != 0 else np.nan
downside_std = portfolio_data.loc[portfolio_data['Daily_Return'] < 0, 'Daily_Return'].std() * np.sqrt(TRADING_DAYS)
sortino_ratio = (annual_return - rf_annual) / downside_std if downside_std != 0 else np.nan
max_drawdown = portfolio_data['Drawdown'].min()

print("\nPerformance Metrics for Regime-Switching Portfolio:")
print(f"  Total Return: {total_return*100:.2f}%")
print(f"  Annualized Return: {annual_return*100:.2f}%")
print(f"  Annualized Volatility: {annual_vol*100:.2f}%")
print(f"  Sharpe Ratio: {sharpe_ratio:.2f}")
print(f"  Sortino Ratio: {sortino_ratio:.2f}")
print(f"  Maximum Drawdown: {max_drawdown:.2f}%")

# =============================================================================
# 6. Output CSV with Daily Component Values
# =============================================================================
portfolio_data['Call_Option_Value'] = portfolio_data.apply(lambda row: row['Option_Value'] if row['Option_Type']=='call' else 0, axis=1)
portfolio_data['Put_Option_Value'] = portfolio_data.apply(lambda row: row['Option_Value'] if row['Option_Type']=='put' else 0, axis=1)

daily_components = portfolio_data[['SP_Allocation', 'Cash_Allocation', 'Call_Option_Value', 'Put_Option_Value']]
daily_components['Total_Portfolio_Value'] = portfolio_data['Current_Portfolio_Value']
daily_components.to_csv('daily_portfolio_components.csv')
print("\nDaily portfolio component values saved to 'daily_portfolio_components.csv'")

# =============================================================================
# 7. Plot Charts
# =============================================================================
fig, axs = plt.subplots(3, 1, figsize=(15, 15))

def thousands(x, pos):
    return f'${x/1000:.0f}k'
formatter = FuncFormatter(thousands)

for col in ['Option_Value', 'SP_Allocation', 'Cash_Allocation']:
    portfolio_data[col] = pd.to_numeric(portfolio_data[col], errors='coerce').fillna(0)

axs[0].plot(data.index, data['BuyHold_Portfolio'], label='Buy-and-Hold', color='blue')
axs[0].plot(portfolio_data.index, portfolio_data['Current_Portfolio_Value'], label='Regime-Switching', color='green')
axs[0].set_title('Portfolio Value Comparison')
axs[0].set_ylabel('Portfolio Value')
axs[0].legend()
axs[0].grid(True, alpha=0.3)
axs[0].yaxis.set_major_formatter(formatter)

last_date = None
last_regime = None
for dt, regime in zip(data.index, data['Regime']):
    if last_regime is None:
        last_regime = regime
        last_date = dt
    elif regime != last_regime:
        axs[0].axvspan(last_date, dt, alpha=0.1, color=f'C{last_regime}')
        last_regime = regime
        last_date = dt
if last_date is not None:
    axs[0].axvspan(last_date, data.index[-1], alpha=0.1, color=f'C{last_regime}')

axs[1].plot(data.index, data['BuyHold_Drawdown'], label='Buy-and-Hold Drawdown', color='red')
axs[1].plot(portfolio_data.index, portfolio_data['Drawdown'], label='Regime-Switching Drawdown', color='orange')
axs[1].set_title('Drawdown Comparison')
axs[1].set_ylabel('Drawdown (%)')
axs[1].legend()
axs[1].grid(True, alpha=0.3)

axs[2].stackplot(portfolio_data.index, 
                 portfolio_data['Option_Value'],
                 portfolio_data['SP_Allocation'],
                 portfolio_data['Cash_Allocation'],
                 labels=['Options', 'S&P500', 'Cash'],
                 colors=['purple', 'green', 'lightblue'])
axs[2].set_title('Portfolio Composition')
axs[2].set_ylabel('Allocation Value')
axs[2].legend(loc='upper left')
axs[2].grid(True, alpha=0.3)
axs[2].yaxis.set_major_formatter(formatter)

plt.tight_layout()
plt.savefig('regime_switching_performance.png', dpi=300)
plt.show()

# =============================================================================
# 8. Additional Debugging and Analysis
# =============================================================================
# Create a sample of the data to check option pricing
sample_size = min(20, len(portfolio_data))
sample_indices = np.linspace(0, len(portfolio_data)-1, sample_size, dtype=int)
sample_data = portfolio_data.iloc[sample_indices].copy()

print("\nSample of Option Pricing Data:")
for idx, row in sample_data.iterrows():
    if pd.notna(row['Option_Strike']) and pd.notna(row['Option_Value']) and pd.notna(row['Option_Units']):
        print(f"Date: {idx.date()} | S&P500: {data.loc[idx, 'S&P500']:.2f} | " + 
              f"Type: {row['Option_Type']} | Strike: {row['Option_Strike']:.2f} | " + 
              f"Days Left: {row['Option_Remaining_Days']} | Value: {row['Option_Value']:.2f}")

# Save additional debug info
option_debug = pd.DataFrame(index=portfolio_data.index)
option_debug['Date'] = portfolio_data.index
option_debug['S&P500'] = data['S&P500']
option_debug['Option_Type'] = portfolio_data['Option_Type']
option_debug['Option_Strike'] = portfolio_data['Option_Strike']
option_debug['Days_Remaining'] = portfolio_data['Option_Remaining_Days']
option_debug['Option_IV'] = portfolio_data['Option_IV']
option_debug['Option_Value'] = portfolio_data['Option_Value']
option_debug['Option_Units'] = portfolio_data['Option_Units']
option_debug['Per_Contract_Value'] = option_debug['Option_Value'] / option_debug['Option_Units']
option_debug.to_csv('option_pricing_debug.csv')
print("\nDetailed option pricing data saved to 'option_pricing_debug.csv'")

portfolio_data.to_csv('regime_switching_option_backtest_results.csv')
print("\nFull portfolio time series saved to 'regime_switching_option_backtest_results.csv'")
